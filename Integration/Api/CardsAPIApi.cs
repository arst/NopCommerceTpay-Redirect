/* 
 * Tpay.com Technical Documentation
 *
 *  <p class=\"changes-disclaimer\"> Demo transaction/masspayments api key: <input type=\"text\" id=\"transaction_key\" value=\"75f86137a6635df826e3efe2e66f7c9a946fdde1\" class=\"ui-form-control\"/><label for=\"transaction_key\" style=\"display: none;\" id=\"tr_api_label\">COPIED!</label><br/><br/> Demo cards api key: <input type=\"text\" id=\"cards_key\" value=\"ba9a05faa697f9b43f39b84933ff168e373c6496\" class=\"ui-form-control\"/><label for=\"cards_key\" style=\"display: none;\" id=\"cards_api_label\">COPIED!</label><br/><br/> Demo registration api key: <input type=\"text\" id=\"registration_key\" value=\"6c0f5ef6e4d6877abad7fcfb3b5de117ad8b772d\" class=\"ui-form-control\"/><label for=\"registration_key\" style=\"display: none;\" id=\"registration_api_label\">COPIED!</label><br/><br/> The terms seller and merchant are used interchangeably and they both refer to a person or a company registered at tpay.com to accept online payments. <br/> Whenever term merchant panel is used it refers to the part of tpay.com website located at <a href=\"https://secure.tpay.com/panel\" target=\"_blank\">secure.tpay.com/panel</a>. <br/><br/> For sandbox purposes use merchant demo account <br/><br/> ID - 1010, Password - demo<br/><br/>Remember that this is a shared account, so all data passed through will be publicly visible.</p>
 *
 * OpenAPI spec version: 1.1.1
 * Contact: pt@tpay.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ICardsAPIApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// check
        /// </summary>
        /// <remarks>
        /// Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>CheckResponse</returns>
        CheckResponse ApiCardsApiKeyCheckPost (string apiKey, CheckFields basicData = null);

        /// <summary>
        /// check
        /// </summary>
        /// <remarks>
        /// Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>ApiResponse of CheckResponse</returns>
        ApiResponse<CheckResponse> ApiCardsApiKeyCheckPostWithHttpInfo (string apiKey, CheckFields basicData = null);
        /// <summary>
        /// deregister
        /// </summary>
        /// <remarks>
        /// The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>InlineResponse200</returns>
        InlineResponse200 ApiCardsApiKeyDeregisterPost (string apiKey, DeregisterFields basicData = null);

        /// <summary>
        /// deregister
        /// </summary>
        /// <remarks>
        /// The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of InlineResponse200</returns>
        ApiResponse<InlineResponse200> ApiCardsApiKeyDeregisterPostWithHttpInfo (string apiKey, DeregisterFields basicData = null);
        /// <summary>
        /// presale
        /// </summary>
        /// <remarks>
        /// The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RegisterSaleResponse</returns>
        RegisterSaleResponse ApiCardsApiKeyPresalePost (string apiKey, PresaleFields basicData = null);

        /// <summary>
        /// presale
        /// </summary>
        /// <remarks>
        /// The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RegisterSaleResponse</returns>
        ApiResponse<RegisterSaleResponse> ApiCardsApiKeyPresalePostWithHttpInfo (string apiKey, PresaleFields basicData = null);
        /// <summary>
        /// refund
        /// </summary>
        /// <remarks>
        /// The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RefundResponse</returns>
        RefundResponse ApiCardsApiKeyRefundPost (string apiKey, RefundFields basicData = null);

        /// <summary>
        /// refund
        /// </summary>
        /// <remarks>
        /// The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RefundResponse</returns>
        ApiResponse<RefundResponse> ApiCardsApiKeyRefundPostWithHttpInfo (string apiKey, RefundFields basicData = null);
        /// <summary>
        /// register sale
        /// </summary>
        /// <remarks>
        /// The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RegisterSaleResponse</returns>
        RegisterSaleResponse ApiCardsApiKeyRegisterSalePost (string apiKey, RegisterSaleFields basicData = null);

        /// <summary>
        /// register sale
        /// </summary>
        /// <remarks>
        /// The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RegisterSaleResponse</returns>
        ApiResponse<RegisterSaleResponse> ApiCardsApiKeyRegisterSalePostWithHttpInfo (string apiKey, RegisterSaleFields basicData = null);
        /// <summary>
        /// sale
        /// </summary>
        /// <remarks>
        /// The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SaleResponse</returns>
        SaleResponse ApiCardsApiKeySalePost (string apiKey, SaleFields basicData = null);

        /// <summary>
        /// sale
        /// </summary>
        /// <remarks>
        /// The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SaleResponse</returns>
        ApiResponse<SaleResponse> ApiCardsApiKeySalePostWithHttpInfo (string apiKey, SaleFields basicData = null);
        /// <summary>
        /// secure sale
        /// </summary>
        /// <remarks>
        ///  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SecuresaleResponse</returns>
        SecuresaleResponse ApiCardsApiKeySecuresalePost (string apiKey, SecuresaleFields basicData = null);

        /// <summary>
        /// secure sale
        /// </summary>
        /// <remarks>
        ///  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SecuresaleResponse</returns>
        ApiResponse<SecuresaleResponse> ApiCardsApiKeySecuresalePostWithHttpInfo (string apiKey, SecuresaleFields basicData = null);
        /// <summary>
        /// visacheckout finish
        /// </summary>
        /// <remarks>
        /// The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SecuresaleResponse</returns>
        SecuresaleResponse ApiCardsApiKeyVisacheckoutFinishPost (string apiKey, VcFinishFields basicData = null);

        /// <summary>
        /// visacheckout finish
        /// </summary>
        /// <remarks>
        /// The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SecuresaleResponse</returns>
        ApiResponse<SecuresaleResponse> ApiCardsApiKeyVisacheckoutFinishPostWithHttpInfo (string apiKey, VcFinishFields basicData = null);
        /// <summary>
        /// visacheckout prepare
        /// </summary>
        /// <remarks>
        /// The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>VcPrepareResponse</returns>
        VcPrepareResponse ApiCardsApiKeyVisacheckoutPreparePost (string apiKey, VcPrepareFields basicData = null);

        /// <summary>
        /// visacheckout prepare
        /// </summary>
        /// <remarks>
        /// The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of VcPrepareResponse</returns>
        ApiResponse<VcPrepareResponse> ApiCardsApiKeyVisacheckoutPreparePostWithHttpInfo (string apiKey, VcPrepareFields basicData = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// check
        /// </summary>
        /// <remarks>
        /// Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>Task of CheckResponse</returns>
        System.Threading.Tasks.Task<CheckResponse> ApiCardsApiKeyCheckPostAsync (string apiKey, CheckFields basicData = null);

        /// <summary>
        /// check
        /// </summary>
        /// <remarks>
        /// Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>Task of ApiResponse (CheckResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CheckResponse>> ApiCardsApiKeyCheckPostAsyncWithHttpInfo (string apiKey, CheckFields basicData = null);
        /// <summary>
        /// deregister
        /// </summary>
        /// <remarks>
        /// The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of InlineResponse200</returns>
        System.Threading.Tasks.Task<InlineResponse200> ApiCardsApiKeyDeregisterPostAsync (string apiKey, DeregisterFields basicData = null);

        /// <summary>
        /// deregister
        /// </summary>
        /// <remarks>
        /// The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse200)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse200>> ApiCardsApiKeyDeregisterPostAsyncWithHttpInfo (string apiKey, DeregisterFields basicData = null);
        /// <summary>
        /// presale
        /// </summary>
        /// <remarks>
        /// The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RegisterSaleResponse</returns>
        System.Threading.Tasks.Task<RegisterSaleResponse> ApiCardsApiKeyPresalePostAsync (string apiKey, PresaleFields basicData = null);

        /// <summary>
        /// presale
        /// </summary>
        /// <remarks>
        /// The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RegisterSaleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RegisterSaleResponse>> ApiCardsApiKeyPresalePostAsyncWithHttpInfo (string apiKey, PresaleFields basicData = null);
        /// <summary>
        /// refund
        /// </summary>
        /// <remarks>
        /// The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RefundResponse</returns>
        System.Threading.Tasks.Task<RefundResponse> ApiCardsApiKeyRefundPostAsync (string apiKey, RefundFields basicData = null);

        /// <summary>
        /// refund
        /// </summary>
        /// <remarks>
        /// The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RefundResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RefundResponse>> ApiCardsApiKeyRefundPostAsyncWithHttpInfo (string apiKey, RefundFields basicData = null);
        /// <summary>
        /// register sale
        /// </summary>
        /// <remarks>
        /// The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RegisterSaleResponse</returns>
        System.Threading.Tasks.Task<RegisterSaleResponse> ApiCardsApiKeyRegisterSalePostAsync (string apiKey, RegisterSaleFields basicData = null);

        /// <summary>
        /// register sale
        /// </summary>
        /// <remarks>
        /// The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RegisterSaleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<RegisterSaleResponse>> ApiCardsApiKeyRegisterSalePostAsyncWithHttpInfo (string apiKey, RegisterSaleFields basicData = null);
        /// <summary>
        /// sale
        /// </summary>
        /// <remarks>
        /// The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SaleResponse</returns>
        System.Threading.Tasks.Task<SaleResponse> ApiCardsApiKeySalePostAsync (string apiKey, SaleFields basicData = null);

        /// <summary>
        /// sale
        /// </summary>
        /// <remarks>
        /// The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SaleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SaleResponse>> ApiCardsApiKeySalePostAsyncWithHttpInfo (string apiKey, SaleFields basicData = null);
        /// <summary>
        /// secure sale
        /// </summary>
        /// <remarks>
        ///  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SecuresaleResponse</returns>
        System.Threading.Tasks.Task<SecuresaleResponse> ApiCardsApiKeySecuresalePostAsync (string apiKey, SecuresaleFields basicData = null);

        /// <summary>
        /// secure sale
        /// </summary>
        /// <remarks>
        ///  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SecuresaleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SecuresaleResponse>> ApiCardsApiKeySecuresalePostAsyncWithHttpInfo (string apiKey, SecuresaleFields basicData = null);
        /// <summary>
        /// visacheckout finish
        /// </summary>
        /// <remarks>
        /// The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SecuresaleResponse</returns>
        System.Threading.Tasks.Task<SecuresaleResponse> ApiCardsApiKeyVisacheckoutFinishPostAsync (string apiKey, VcFinishFields basicData = null);

        /// <summary>
        /// visacheckout finish
        /// </summary>
        /// <remarks>
        /// The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SecuresaleResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SecuresaleResponse>> ApiCardsApiKeyVisacheckoutFinishPostAsyncWithHttpInfo (string apiKey, VcFinishFields basicData = null);
        /// <summary>
        /// visacheckout prepare
        /// </summary>
        /// <remarks>
        /// The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of VcPrepareResponse</returns>
        System.Threading.Tasks.Task<VcPrepareResponse> ApiCardsApiKeyVisacheckoutPreparePostAsync (string apiKey, VcPrepareFields basicData = null);

        /// <summary>
        /// visacheckout prepare
        /// </summary>
        /// <remarks>
        /// The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (VcPrepareResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<VcPrepareResponse>> ApiCardsApiKeyVisacheckoutPreparePostAsyncWithHttpInfo (string apiKey, VcPrepareFields basicData = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class CardsAPIApi : ICardsAPIApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CardsAPIApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CardsAPIApi(String basePath)
        {
            this.Configuration = new Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CardsAPIApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CardsAPIApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// check Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>CheckResponse</returns>
        public CheckResponse ApiCardsApiKeyCheckPost (string apiKey, CheckFields basicData = null)
        {
             ApiResponse<CheckResponse> localVarResponse = ApiCardsApiKeyCheckPostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// check Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>ApiResponse of CheckResponse</returns>
        public ApiResponse< CheckResponse > ApiCardsApiKeyCheckPostWithHttpInfo (string apiKey, CheckFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyCheckPost");

            var localVarPath = "/api/cards/{api_key}/check";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyCheckPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CheckResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CheckResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CheckResponse)));
        }

        /// <summary>
        /// check Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>Task of CheckResponse</returns>
        public async System.Threading.Tasks.Task<CheckResponse> ApiCardsApiKeyCheckPostAsync (string apiKey, CheckFields basicData = null)
        {
             ApiResponse<CheckResponse> localVarResponse = await ApiCardsApiKeyCheckPostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// check Method, which can be used to ping our API server to establish a monitoring service on the Merchant system.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">check method data (optional)</param>
        /// <returns>Task of ApiResponse (CheckResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CheckResponse>> ApiCardsApiKeyCheckPostAsyncWithHttpInfo (string apiKey, CheckFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyCheckPost");

            var localVarPath = "/api/cards/{api_key}/check";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyCheckPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CheckResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CheckResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(CheckResponse)));
        }

        /// <summary>
        /// deregister The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>InlineResponse200</returns>
        public InlineResponse200 ApiCardsApiKeyDeregisterPost (string apiKey, DeregisterFields basicData = null)
        {
             ApiResponse<InlineResponse200> localVarResponse = ApiCardsApiKeyDeregisterPostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// deregister The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of InlineResponse200</returns>
        public ApiResponse< InlineResponse200 > ApiCardsApiKeyDeregisterPostWithHttpInfo (string apiKey, DeregisterFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyDeregisterPost");

            var localVarPath = "/api/cards/{api_key}/deregister";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyDeregisterPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse200>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (InlineResponse200) Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse200)));
        }

        /// <summary>
        /// deregister The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of InlineResponse200</returns>
        public async System.Threading.Tasks.Task<InlineResponse200> ApiCardsApiKeyDeregisterPostAsync (string apiKey, DeregisterFields basicData = null)
        {
             ApiResponse<InlineResponse200> localVarResponse = await ApiCardsApiKeyDeregisterPostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// deregister The method used to deregister client credit card token from Tpay and Merchant system.&lt;br/&gt;A client can also do it himself from the link in an email after payment.&lt;br/&gt;&lt;br/&gt;After successful deregistration Merchant will not be able anymore to charge client&#39;s card. Tpay system sends notification about this deregistration to merchant endpoint, defined in merchant panel settings.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To test this method you need to generate client token and calculate sign with your own API access data.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse200)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse200>> ApiCardsApiKeyDeregisterPostAsyncWithHttpInfo (string apiKey, DeregisterFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyDeregisterPost");

            var localVarPath = "/api/cards/{api_key}/deregister";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyDeregisterPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse200>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (InlineResponse200) Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse200)));
        }

        /// <summary>
        /// presale The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RegisterSaleResponse</returns>
        public RegisterSaleResponse ApiCardsApiKeyPresalePost (string apiKey, PresaleFields basicData = null)
        {
             ApiResponse<RegisterSaleResponse> localVarResponse = ApiCardsApiKeyPresalePostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// presale The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RegisterSaleResponse</returns>
        public ApiResponse< RegisterSaleResponse > ApiCardsApiKeyPresalePostWithHttpInfo (string apiKey, PresaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyPresalePost");

            var localVarPath = "/api/cards/{api_key}/presale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyPresalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RegisterSaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RegisterSaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RegisterSaleResponse)));
        }

        /// <summary>
        /// presale The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RegisterSaleResponse</returns>
        public async System.Threading.Tasks.Task<RegisterSaleResponse> ApiCardsApiKeyPresalePostAsync (string apiKey, PresaleFields basicData = null)
        {
             ApiResponse<RegisterSaleResponse> localVarResponse = await ApiCardsApiKeyPresalePostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// presale The method used to create a new sale for payment on demand. It can be called after receiving a notification with client registered token (cli_auth parameter). It can not be used if &#39;onetimer&#39; parameter was sent in register_sale or client has unregistered (by the link in an email sent by tpay.com after registering client’s credit card or by API).&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-platnosci-rekurencyjnych-cyklicznych\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the recurrent payments&lt;/a&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RegisterSaleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RegisterSaleResponse>> ApiCardsApiKeyPresalePostAsyncWithHttpInfo (string apiKey, PresaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyPresalePost");

            var localVarPath = "/api/cards/{api_key}/presale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyPresalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RegisterSaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RegisterSaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RegisterSaleResponse)));
        }

        /// <summary>
        /// refund The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RefundResponse</returns>
        public RefundResponse ApiCardsApiKeyRefundPost (string apiKey, RefundFields basicData = null)
        {
             ApiResponse<RefundResponse> localVarResponse = ApiCardsApiKeyRefundPostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// refund The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RefundResponse</returns>
        public ApiResponse< RefundResponse > ApiCardsApiKeyRefundPostWithHttpInfo (string apiKey, RefundFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyRefundPost");

            var localVarPath = "/api/cards/{api_key}/refund";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyRefundPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RefundResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RefundResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RefundResponse)));
        }

        /// <summary>
        /// refund The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RefundResponse</returns>
        public async System.Threading.Tasks.Task<RefundResponse> ApiCardsApiKeyRefundPostAsync (string apiKey, RefundFields basicData = null)
        {
             ApiResponse<RefundResponse> localVarResponse = await ApiCardsApiKeyRefundPostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// refund The method used to transfer money back to the client. The refund can reference to chosen sale (sale_auth) or directly to the client (cli_auth).&lt;br/&gt;&lt;br/&gt; In both cases, the amount is adjustable in parameter amount. If the only cli_auth is sent amount parameter is required, if sale_auth is passed amount and currency is not necessary - the system will take default values from the specified sale.&lt;br/&gt;With sale_auth refund can be made only once. &lt;br&gt;&lt;br/&gt; Parameter status is randomly picked in test mode. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; This method works only in production mode. To test this method you need to create and pay for production transaction with your own API access.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RefundResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RefundResponse>> ApiCardsApiKeyRefundPostAsyncWithHttpInfo (string apiKey, RefundFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyRefundPost");

            var localVarPath = "/api/cards/{api_key}/refund";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyRefundPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RefundResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RefundResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RefundResponse)));
        }

        /// <summary>
        /// register sale The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>RegisterSaleResponse</returns>
        public RegisterSaleResponse ApiCardsApiKeyRegisterSalePost (string apiKey, RegisterSaleFields basicData = null)
        {
             ApiResponse<RegisterSaleResponse> localVarResponse = ApiCardsApiKeyRegisterSalePostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// register sale The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of RegisterSaleResponse</returns>
        public ApiResponse< RegisterSaleResponse > ApiCardsApiKeyRegisterSalePostWithHttpInfo (string apiKey, RegisterSaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyRegisterSalePost");

            var localVarPath = "/api/cards/{api_key}/register_sale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyRegisterSalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RegisterSaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RegisterSaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RegisterSaleResponse)));
        }

        /// <summary>
        /// register sale The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of RegisterSaleResponse</returns>
        public async System.Threading.Tasks.Task<RegisterSaleResponse> ApiCardsApiKeyRegisterSalePostAsync (string apiKey, RegisterSaleFields basicData = null)
        {
             ApiResponse<RegisterSaleResponse> localVarResponse = await ApiCardsApiKeyRegisterSalePostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// register sale The method used to create sale initialisation in tpay.com system. The successful request returns sale_auth used to redirect a client to transaction panel. &lt;br&gt;&lt;br&gt;The parameter sale_auth can be used to redirect a client to payment transaction panel:  &lt;br&gt; &lt;b&gt; https://secure.tpay.com/cards/ &lt;/b&gt;&lt;br&gt; with argument sale_auth passed with the POST or GET method. &lt;br&gt;&lt;br&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;&lt;br&gt; In test mode, the transaction panel offers multiple system answers. You can choose at the transaction panel (instead of making a real transaction) to accept or decline payment to test all paths. In production mode client will be directly redirected to payment gateway with credit card data form. &lt;br&gt; Notification about positive transaction status will be sent to result URL which is set in account settings. 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (RegisterSaleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RegisterSaleResponse>> ApiCardsApiKeyRegisterSalePostAsyncWithHttpInfo (string apiKey, RegisterSaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyRegisterSalePost");

            var localVarPath = "/api/cards/{api_key}/register_sale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyRegisterSalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RegisterSaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RegisterSaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RegisterSaleResponse)));
        }

        /// <summary>
        /// sale The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SaleResponse</returns>
        public SaleResponse ApiCardsApiKeySalePost (string apiKey, SaleFields basicData = null)
        {
             ApiResponse<SaleResponse> localVarResponse = ApiCardsApiKeySalePostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// sale The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SaleResponse</returns>
        public ApiResponse< SaleResponse > ApiCardsApiKeySalePostWithHttpInfo (string apiKey, SaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeySalePost");

            var localVarPath = "/api/cards/{api_key}/sale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeySalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SaleResponse)));
        }

        /// <summary>
        /// sale The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SaleResponse</returns>
        public async System.Threading.Tasks.Task<SaleResponse> ApiCardsApiKeySalePostAsync (string apiKey, SaleFields basicData = null)
        {
             ApiResponse<SaleResponse> localVarResponse = await ApiCardsApiKeySalePostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// sale The method used to execute created sale with presale method. Sale defined with sale_auth can be executed only once. If the method is called second time with the same parameters, the system returns actual sale status - in parameter status - done for correct payment and declined for rejected payment. In that case, client card is not charged the second time. &lt;br&gt;&lt;br&gt; Passed cli_auth has to match with cli_auth used while creating a sale in presale method. &lt;br&gt;&lt;br&gt;&lt;b&gt;Test mode notice!&lt;/b&gt; The method will return correct status with 50% probability. The same concerns declined status. In this case, reason value is also randomly picked.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SaleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SaleResponse>> ApiCardsApiKeySalePostAsyncWithHttpInfo (string apiKey, SaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeySalePost");

            var localVarPath = "/api/cards/{api_key}/sale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeySalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SaleResponse)));
        }

        /// <summary>
        /// secure sale  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SecuresaleResponse</returns>
        public SecuresaleResponse ApiCardsApiKeySecuresalePost (string apiKey, SecuresaleFields basicData = null)
        {
             ApiResponse<SecuresaleResponse> localVarResponse = ApiCardsApiKeySecuresalePostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// secure sale  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SecuresaleResponse</returns>
        public ApiResponse< SecuresaleResponse > ApiCardsApiKeySecuresalePostWithHttpInfo (string apiKey, SecuresaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeySecuresalePost");

            var localVarPath = "/api/cards/{api_key}/securesale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeySecuresalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SecuresaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SecuresaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SecuresaleResponse)));
        }

        /// <summary>
        /// secure sale  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SecuresaleResponse</returns>
        public async System.Threading.Tasks.Task<SecuresaleResponse> ApiCardsApiKeySecuresalePostAsync (string apiKey, SecuresaleFields basicData = null)
        {
             ApiResponse<SecuresaleResponse> localVarResponse = await ApiCardsApiKeySecuresalePostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// secure sale  This method allows Merchant to host payment form on his website and perform sale without any client redirection to tpay.com  system. Securesale method supports 3D Secure validation which is an additional security layer for online credit and debit card transactions. This approach requires special security considerations. We support secure communication by encrypting card data (card number, validity date and cvv/cvs number) on the client side (javascript) with Merchant public RSA key and send it as one parameter (card) to our API gate. A valid SSL certificate on the Merchant domain is required. Application flow is presented below for clarification:&lt;br/&gt;&lt;br/&gt; 1. Generate webpage with your public RSA key in javascript&lt;br/&gt; 2. Before sending payment form, insert new input with encrypted card data using your public key and clear inputs with card data so only encrypted data will be sent and submit form. &lt;br/&gt; 3. In backend prepare parameters and send them with securesale method  &lt;br/&gt; 4. Inform client about payment result&lt;br/&gt; &lt;br/&gt; Card cypher is made from string&lt;br/&gt;&lt;br/&gt; card number|expiry date(MM/YY or MM/YYYY)|cvv or cvc|host  &lt;br/&gt;&lt;br/&gt; eg. \&quot;1234567891234567|05/17|123|https://merchantwebsite.com\&quot;  &lt;br/&gt;&lt;br/&gt; We have published code samples, libraries and instructions to give some insights on the process - see https://github.com/tpay-com/tpay-php . The library used in the example has a limit of 117 input characters for encryption.  &lt;br/&gt; &lt;b&gt;In production mode, this generated hash works only once and should always be generated even for the same card data.&lt;/b&gt;&lt;br/&gt;&lt;br/&gt; There are two ways for performing payment&lt;br/&gt;&lt;br/&gt; a)  &lt;b&gt;Pay by card without  3D- Secure.&lt;/b&gt; &lt;br/&gt; If input parameters are correct, request is processed correctly and the entered card does not have the 3D-Secure option enabled, method returns parameters in JSON format&lt;br/&gt;&lt;br/&gt; b)  &lt;b&gt;Pay by card with 3D-Secure.&lt;/b&gt; &lt;br/&gt;If input parameters are correct, the request is processed correctly and the card has enabled the 3D-Secure, the method returns the 3ds_url parameter in JSON format. &lt;br/&gt;&lt;br/&gt; An example 3ds URL is presented below &lt;br/&gt;&lt;br/&gt; https://secure.tpay.com/cards/?sale_auth&#x3D;2587bf3a98dfa699ef9d01eba38359b7 &lt;br/&gt;&lt;br/&gt; •  The best way to implement 3DS is to open a link to 3D-Secure authentication in a new window. If this method is used, parameter \&quot;enable_pow_url\&quot;  should be sent with value 1.  After a correct authorization, a customer will be redirected to the Merchant’s Site. Return URL is set in Merchant’s Panel or sent dynamically. &lt;br/&gt;&lt;br/&gt; •  Do not use an inline frame to implement the 3D-Secure authentication on Merchant’s Site. In this case, some banks can block 3DS authorisation. &lt;br/&gt;&lt;br/&gt; The parameters are sent with POST method. Merchant system has to respond to the notification by printing array in JSON format.&lt;br/&gt; See Card&#39;s notifications section.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Test mode notice!&lt;/b&gt;  &lt;br/&gt;In test mode, transaction panel offers the choice of system answer for transactions with 3D-Secure authentication. You can choose to accept or decline payment to test all paths.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Additional information&lt;/b&gt; Please feel free to read detailed case study of &lt;a href&#x3D;\&quot;https://support.tpay.com/en/case-study/wdrozenie-bramki-platnosci-kartami-na-stronie-sklepu\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Implementation of the card payment gateway at the store&#39;s website&lt;a/&gt;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SecuresaleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SecuresaleResponse>> ApiCardsApiKeySecuresalePostAsyncWithHttpInfo (string apiKey, SecuresaleFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeySecuresalePost");

            var localVarPath = "/api/cards/{api_key}/securesale";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeySecuresalePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SecuresaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SecuresaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SecuresaleResponse)));
        }

        /// <summary>
        /// visacheckout finish The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>SecuresaleResponse</returns>
        public SecuresaleResponse ApiCardsApiKeyVisacheckoutFinishPost (string apiKey, VcFinishFields basicData = null)
        {
             ApiResponse<SecuresaleResponse> localVarResponse = ApiCardsApiKeyVisacheckoutFinishPostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// visacheckout finish The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of SecuresaleResponse</returns>
        public ApiResponse< SecuresaleResponse > ApiCardsApiKeyVisacheckoutFinishPostWithHttpInfo (string apiKey, VcFinishFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyVisacheckoutFinishPost");

            var localVarPath = "/api/cards/{api_key}/visacheckout_finish";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyVisacheckoutFinishPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SecuresaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SecuresaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SecuresaleResponse)));
        }

        /// <summary>
        /// visacheckout finish The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of SecuresaleResponse</returns>
        public async System.Threading.Tasks.Task<SecuresaleResponse> ApiCardsApiKeyVisacheckoutFinishPostAsync (string apiKey, VcFinishFields basicData = null)
        {
             ApiResponse<SecuresaleResponse> localVarResponse = await ApiCardsApiKeyVisacheckoutFinishPostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// visacheckout finish The Method used to finish Visa Checkout payment. &lt;br/&gt;&lt;br/&gt; Summary_data has format compliant with Visa Checkout Summary Payment Data. Its structure is described in Visa Checkout documentation at &lt;a href&#x3D;\&quot;https://developer.visa.com/products/visa_checkout/guides#extracting-consumer-data\&quot;&gt;extracting-consumer-data&lt;/a&gt;&lt;br&gt;&lt;br/&gt; The example table with this format can be found at &lt;a href&#x3D;\&quot;https://developer.visa.com/capabilities/visa_checkout/docs#pdfs_for_merchants_integrating_with_visa_checkout\&quot;&gt;Link&lt;/a&gt; &lt;br&gt;&lt;br&gt;When some data change between visacheckout_prepare and visacheckout_finish, you should send the modified data with the summary_data table. You can only send to tpay.com the data, which changes (i.e. only the amount ) but you need to send it in the summary_data JSON structure. &lt;br/&gt;Other fields if not changed don’t have to be sent.&lt;br/&gt; The response format is the same as in SecureSale method - see the method for more details.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (SecuresaleResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SecuresaleResponse>> ApiCardsApiKeyVisacheckoutFinishPostAsyncWithHttpInfo (string apiKey, VcFinishFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyVisacheckoutFinishPost");

            var localVarPath = "/api/cards/{api_key}/visacheckout_finish";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyVisacheckoutFinishPost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SecuresaleResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SecuresaleResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(SecuresaleResponse)));
        }

        /// <summary>
        /// visacheckout prepare The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>VcPrepareResponse</returns>
        public VcPrepareResponse ApiCardsApiKeyVisacheckoutPreparePost (string apiKey, VcPrepareFields basicData = null)
        {
             ApiResponse<VcPrepareResponse> localVarResponse = ApiCardsApiKeyVisacheckoutPreparePostWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;
        }

        /// <summary>
        /// visacheckout prepare The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>ApiResponse of VcPrepareResponse</returns>
        public ApiResponse< VcPrepareResponse > ApiCardsApiKeyVisacheckoutPreparePostWithHttpInfo (string apiKey, VcPrepareFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyVisacheckoutPreparePost");

            var localVarPath = "/api/cards/{api_key}/visacheckout_prepare";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyVisacheckoutPreparePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VcPrepareResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VcPrepareResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(VcPrepareResponse)));
        }

        /// <summary>
        /// visacheckout prepare The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of VcPrepareResponse</returns>
        public async System.Threading.Tasks.Task<VcPrepareResponse> ApiCardsApiKeyVisacheckoutPreparePostAsync (string apiKey, VcPrepareFields basicData = null)
        {
             ApiResponse<VcPrepareResponse> localVarResponse = await ApiCardsApiKeyVisacheckoutPreparePostAsyncWithHttpInfo(apiKey, basicData);
             return localVarResponse.Data;

        }

        /// <summary>
        /// visacheckout prepare The method used to prepare Visa Checkout payment. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;NOTICE:&lt;/b&gt; To use Visa Checkout methods, you need to have access to cards API at your account and pass Visa requirements (see Visa Checkout Integration section).
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="apiKey">The api key.</param>
        /// <param name="basicData">Transaction data. (optional)</param>
        /// <returns>Task of ApiResponse (VcPrepareResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<VcPrepareResponse>> ApiCardsApiKeyVisacheckoutPreparePostAsyncWithHttpInfo (string apiKey, VcPrepareFields basicData = null)
        {
            // verify the required parameter 'apiKey' is set
            if (apiKey == null)
                throw new ApiException(400, "Missing required parameter 'apiKey' when calling CardsAPIApi->ApiCardsApiKeyVisacheckoutPreparePost");

            var localVarPath = "/api/cards/{api_key}/visacheckout_prepare";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (apiKey != null) localVarPathParams.Add("api_key", Configuration.ApiClient.ParameterToString(apiKey)); // path parameter
            if (basicData != null && basicData.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(basicData); // http body (model) parameter
            }
            else
            {
                localVarPostBody = basicData; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ApiCardsApiKeyVisacheckoutPreparePost", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<VcPrepareResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (VcPrepareResponse) Configuration.ApiClient.Deserialize(localVarResponse, typeof(VcPrepareResponse)));
        }

    }
}
